# $.embedProxy( getter, caller ): tQuery | Proxy

对 `$` 嵌入 `get` 和 `apply` 代理，分别用于获取 `$` 的方法成员和 `$(...)` 调用覆盖。


## 参数

### getter: Function

`$` 内成员方法的获取函数，接口：`function( fn, $ ): Function | null`，实参 `fn` 即为当前调用的目标方法，实参 `$` 为嵌入之前的 `$` 对象，这是代理中正常使用的目标（否则会导致自我循环）。

返回的方法应当与目标方法 `[fn]` 有相同的声明和兼容的功能实现，如果返回 `null` 或其它假值，表示不代理该方法。


### caller: Function

`$` 调用本身的代理覆盖，接口：`function( $, slr, ctx, doc ): Collector`，首个实参 `$` 为嵌入之前的 `$` 对象（同上），其余实参为 `tQuery()` 原始的参数定义。

因为全局的 `window.$` 会被覆盖，所以代理内应当使用该 `$` 对象以避免自我循环。


### 返回值

返回原始 `tQuery`（首次调用时），或前阶被嵌入的代理对象（`Proxy`）。


## 示例

```html
<p id="test" class="Test">
    这是一个<strong>测试</strong><em>段落</em>。
</p>
```


### 嵌入代理前

```js
p = $.get('#test');
$.hasClass(p, 'Test');      // true
$.hasClass(p, 'Good');      // false
```


### 嵌入代理后

```js
let hasClassX = function( el, name ) {
    // 注意使用前阶$绑定！
    return `${el.tagName}:${name} ~ ` + this.hasClass(el, name);
};

let getter = function( fn, $ ) {
    // 仅改变 hasClass 接口
    return fn == 'hasClass' ? hasClassX.bind($) : null;
};

$.embedProxy(getter);

$.hasClass(p, 'Test');  // "P:Test ~ true"
$.hasClass(p, 'Good');  // "P:Good ~ false"

// 其它接口不受影响
$.attr(p, 'class');     // "Test Hai"
```


### 可多重嵌入代理

```js
// 嵌入之前
$.children(p);  // [<strong>, <em>]


function childrenX( el, slr ) {
    return `embed: ${el.nodeName}`;
}
let getter2 = fn => (fn === 'children') ? childrenX : null;

let $prev = $.embedProxy(getter2);


$.children(p);
// "embed: P"

$.hasClass(p, 'Test');
// "P:Test ~ true"
// 注：前阶代理依然有效。

$.attr(p, 'id');
// "test"
// 注：无关接口保持原样。


$prev.children(p);
// [<strong>, <em>]
// 注：使用嵌入之前的 $，正常。
```


### 代理 $ 调用本身

```js
let caller = function( $, ...rest ) {
    console.info('Hai, in $(...) proxy.');
    // 局部 $
    return $(...rest);
}

$.embedProxy( null, caller );

$('#test > *');
// Hai, in $(...) proxy.
// Collector [<strong>, <em>]
```
