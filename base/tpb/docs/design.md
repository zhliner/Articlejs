# Tpb 详细设计

> `tpb`: Template Presentational Behavior


## 目的

在HTML上简单直观地设计UI。因为UI的交互逻辑也应当属于页面设计师的工作，所以事件的绑定规划也需要包含。

HTML的代码有着严格的树形结构，虽然浏览器可以正常解析杂乱无章的HTML源码，但这样的结构也可以是人工友好的，设计师可以在这样的树形结构中思考。同时，简明清晰的HTML源码既方便分享，也可以节省数据的存储和流量。

HTML源码不应当脱离设计师的视野，**源码**这一逻辑也并不就是程序员专属，实际上，HTML就是一种模板，在模板上定义交互逻辑十分正常。因此，本设计中的事件绑定在模板中定义，由设计师完全主导。设计师唯一需要知道的是有哪些数据可用，而这些数据都是纯数据，与页面展示无关。

同时，程序员也不需要知道数据将如何展现，即：理论上，数据中不应当有HTML标签结构。



## 指令

以模板为驱动，功能指令书写在HTML元素上，自动解析完成事件的绑定和行为序列的编译。

1. **行为定义：**<br>
    由三个属性 `on`、`by`、`to` 定义，在元素上配置需要处理的事件和相应的行为链。其中：
    - `on`：事件绑定和取值逻辑。
    - `by`：具体的业务处理，可选。复杂时可划分为 `CMV`（`Control`, `Model`, `View`）三个层次。
    - `to`：用业务环节来的数据更新UI。逻辑上可选，但通常是必需的。

2. **节点渲染：**<br>
    由九个渲染属性 `tpb-[for|each|if|else|with|var|switch|case|last]` 表达模板的语法结构，以及一个 **属性名前置下划线** 指定属性赋值的规则，如：`_href="$.url"` 表示对 `href` 属性赋值为变量 `url` 的值。
    - `tpb-for`: 子元素的循环。
    - `tpb-each`: 当前元素的循环迭代。
    - `tpb-if`: 当前元素 if 测试，真值显示，假值隐藏。
    - `tpb-else`: 当前元素 else 测试，与 `if` 匹配使用。可以包含条件，此时即为 elseif 逻辑。
    - `tpb-with`: 新建局部域，变量引用为局部域成员。
    - `tpb-var`: 新建变量，方便后续简化使用。
    - `tpb-switch`: 创建子元素 `switch` 逻辑。
    - `tpb-case`: 当前元素 `case` 测试，与 `switch` 标的值比较，相等则显示，否则隐藏。
    - `tpb-last`: `switch` 的最后分支，无值时为 default 逻辑，有值时为 `case` 逻辑，但不匹配时会隐藏整个 `switch` 结构。

3. **模板管理：**<br>
    由三个属性 `tpl-[name|node|source]` 配置。
    - `tpl-name`: 当前元素命名为一个具名模板，用于外部检索或子模版导入时引用。
    - `tpl-node`: 引入克隆的模板节点（`replace`）。支持同时定义多个节点，各名称间逗号（`,`）分隔。
    - `tpl-source`: 引入元素的模板节点。同上支持。



## OBT

`OBT` 即**行为定义**中 `on/by/to` 的简写。事件/行为在这三个属性上定义，系统自动解析，绑定目标事件名并构造相应的**调用链**。

调用链可视为一个指令/方法的序列，它们对一个共同的数据栈（**后进先出**）进行操作，返回的值（除了 `undefined`）会自动压入数据栈（栈顶）。形象地看，调用链有点象流水线，线上的各个指令对数据栈依次处理并把结果入栈供后续指令使用，这些数据被称为**流程数据**，而这条流水线也被称为**执行流**。


### 数据获取

数据栈内的数据需要取出后再用于指令的实参，它们是指令操作的目标。取出的数据先被放在一个称为**暂存区**的队列中（**先进先出**），可以一次取出多个，也可以连续或间断多次取出。指令需要的实参先从暂存区（队列头部）获取，如果暂存区已空，则自动从数据栈（栈顶）提取。存在于暂存区队列头部当前需要的数据称为**当前条目**。

**暂存区**的设计是为了让线性的指令序列模式获得一种腾挪的能力。因为上一阶指令的结果会自动入栈，而下一阶指令需要的实参未必就是该值，所以一个与指令序列同向的先进先出的队列可以让用户提前布置实参。


### 分组对应的配置格式

`On/By/To` 上的配置可以有多组，每一组用分号（`;`）分隔，多组之间严格地按位置对应，如：

```html
<article
    on="AA; BB; CC"
    by="Xx; -;  Zz"
    to="T1; T2">
</article>
<!-- 注：分号后的空格可选 -->
```

**说明：**

- **`{ AA / Xx / T1 }`** 为一组行为链，分别对应于 `On / By / To` 各自的逻辑。
- **`{ BB / - / T2 }`**  为一组行为链，OBT对应逻辑同上，但其中 `By` 是一个空值（无定义，`-` 为占位符）。
- **`{ CC / Zz / - }`**  为一组行为链，OBT对应逻辑同前，但末尾的 `To` 没有定义（占位符在末尾时可省略）。


### 隐形的首个实参

所有方法中的首个实参都为 `evo`（event-value-object），它们是在方法调用时自动传入的，在模板中并不可见。

```js
evo: {
    origin: {Element}               // 事件起点元素（event.target）
    current: {Element}              // 触发事件的当前元素（matched|event.currentTarget）
    delegate: {Element}             // 委托绑定的元素（event.currentTarget）
    related: {Element|null}         // 事件相关联元素（event.relatedTarget）

    event: {Event}                  // 原生事件对象（未侵入）
    selector: {String|null}         // 委托匹配选择器（for match）]
    data: {Value|[Value]|undefined} // 自动获取的流程数据（从暂存区或数据栈来）

    entry: {Function}               // 迭代入口函数，由entry指令创建。其它指令内部也可直接调用：evo.entry(...)
    targets: {Element|Collector}    // To目标元素（集）向后延续，在 To:Query 之后存在
}
```

其中 `evo.data` 是由暂存区或数据栈中取出的条目，即方法操作的目标。是否从数据栈中取值或取值的特性由方法的 `[EXTENT]` 属性配置，含义如下：

- `1`  暂存区有值则取出1项，否则取栈顶1项（值）。
- `n`  暂存区有值则取出n项（可能不足n项），否则取栈顶n项（构建为数组）。
- `0`  暂存区有值则取出全部（清空），无值也不取栈。
- `-1` 暂存区有值则取出1项，无值也不取栈。
- `-n` 暂存区有值则取出n项（可能不足n项），无值也不取栈。
- `null|undefined` 指令自己操作数据栈（有特权时），或无需流程数据。

如果方法需要操作数据栈本身，需要标记 `[ACCESS]` 为 `true`（特权），这时第二个实参即为数据栈实例（通常名为 `stack`），这在模板中也不可见。


#### 附1：流程数据依赖的几种情形

1. 如果方法**明确需要**有操作目标，此时应当要求自动取栈。`[EXTENT]` 配置为需要的流程数据条目数。
2. 如果目标**可有可无**，此时目标应该是可选的，不应当要求自动取栈。`[EXTENT]` 配置值为 `0`。
3. 如果方法没有对流程数据有要求，即无需操作目标。此时 `[EXTENT]` 可能为 `null` 或 `undefined`，暂存区会保持原样。
4. 有的方法需要根据模板实参自行判断灵活取栈，此时 `[EXTENT]` 也应当为 `null`。


#### 附2：自定义函数的复杂性限制

用户可以在模板中使用字符代码创建函数，但这是有限度的：**只支持表达式代码**（即不能有 `return`）。你也可以使用箭头（`=>`）语法创建简单的箭头函数。

简单的函数支持用于满足小而灵活的需求，复杂的函数应当定义在By部分的 `X.Fun` 空间并通过 `xobj` 指令引用。


### `obted` 事件

系统提供一个自定义事件：当一个元素/对象的 OBT 构建完成后，向元素发送一个**非冒泡**并**不可取消**的事件 `obted`，这在某些情况下很有用。



## 全局指令集

### 顶层全局（适用 On/By/To 三个域）

```js
$( rid: String ): Element
// 检索单个元素入栈。

$$( rid: String|Value ): Collector
// 检索元素集入栈。

evo( name: String|Number ): Value
// 从当前evo对象上取值入栈。
// name: {
//      0|'event'     evo.event
//      1|'origin'    evo.origin
//      2|'current'   evo.current
//      3|'delegate'  evo.delegate
//      4|'related'   evo.related
//      5|'selector'  evo.selector
//     10|'data'      evo.data （前端最后取出值遗留）
//     11|'entry',    evo.entry （中段入口，迭代重入）
//     12|'targets'   evo.targets （To检索目标延续传递）
// }

ev( name?: String ): Value|[Value]
// 从事件对象上取值入栈。

tpl( name?: String, clone?: Boolean ): Promise<Element>
// 获取name模板节点。



// 控制类
//===============================================

pass( val? ): void
// 通过性检查。

avoid( back? ): back|void
// 停止事件默认的行为。

stop( back? ): back|void
// 停止事件冒泡。

stopAll( back? ): back|void
// 停止事件冒泡并阻止本事件其它处理器的执行。

end( val? ): void
// 流程终止。



//
// 特殊控制
// 需要this为指令单元（Cell），不预绑定。
//===============================================

prune( cnt = 1, n:Number = 1 ): void
// 移除后端跟随指令（n个）。
// 目标：无。
// 允许跟随指令执行cnt次。
// 注：
// 可以传递cnt为0（立即移除），基本没有意义。负值忽略。

prunes( cnt:Number = 1 ): void
// 持续移除后端跟随指令
// 注：每次一个，直到链末尾。
// 目标：无。
// 逐次移除，每次都允许跟随指令执行cnt次。


entry()
// 创建入口方法。
// 在执行流中创建一个入口，可从该处开始执行。
// 目标：无。
// 可用于如动画之类的重复执行（前端收集数据，后段迭代循环）。
// 实现：
// 就是封装了下一指令单元的call方法，即从下一指令单元执行call(...)。
// 注：
// 该方法需要在外部定义（不经过预绑定处理）。

reenter( count, val )
// 重入流程（entry处）。
// 目标：当前条目，可选（入口实参）。
// count 为迭代次数，负值表示无限。
// val 是初次迭代传入evo.entry()的值（如果有），后续采用当前条目（如果有）。
// 注：
// 需要先定义entry才有效。也在外部定义（需要this:Cell）。

debug( keep:false ): Value
// 控制台调试打印。
// 目标：无。
// 特权：是，数据查看。
// 传递keep实参为false会终止执行流。



// 暂存区赋值。
// 目标：无。
// 特权：是，操作数据栈接口。
//===============================================

pop( n ): void
// 弹出栈顶n个条目。
// 弹出n项压入暂存区，无实参调用视为1项。

shift( n ): void
// 取出栈底n个条目。
// 移除栈底n项压入暂存区，无实参调用视为1项。

index( ...ns ): void
// 引用目标位置项。
// 下标位置支持负数从末尾算起。
// 注意：非法的下标位置会导入一个undefined值。



// 数据栈操作。
//===============================================

pack( n: Number ): [Value]
// 栈顶条目打包封装。
// 取出栈顶的n项打包为一个数组入栈。
// 目标：无。
// 特权：是，自行操作数据栈。
// 必然会返回一个数组，非法值返回一个空数组。

slice( begin, end ): void
// 任意区段打包。
// 目标：无。
// 特权：是，自行操作数据栈。
// 两个位置下标支持负值从末尾倒算。

spread(): [...Value]
// 集合条目展开入栈。
// 目标：当前条目/栈顶1项。
// 特权：是，自行入栈。
// 目标若为字符串，会展开为单个字符序列入栈。
// 注：目标中的undefined值会被忽略。

scrap( start, count ): void
// 剔除任意区段条目。
// 目标：无。
// 特权：是，自行操作数据栈。
// 位置指定支持负数从末尾算起。
// 如果count未指定，表示删除start之后全部。
// 注：
// 可能用于移除多余的初始传送数据。



// 其它
//===============================================

nil(): undefined
// 压入一个特殊值（undefined）。
// 目标：无。
// 特权：是，定制压入。
// 常用于向栈内填充无需实参的占位值。

set( name: String, val: Value|[Value] ): void
// 设置目标成员值。
// 目标：当前条目/栈顶1项。
// name支持空格分隔多个名称，
// 如果名称为多个且值为数组，为一一对应设置，否则值设置到多个名称。
// 注：会修改目标对象自身。
```


### 运算全局（仅用于 On/By 两个域）

```js
// 类型转换
// 目标：当前条目/栈顶1项。
//===============================================

Int( radix ): Number
// 将字符串转为整数，即 parseInt()

Float(): Number
// 将字符串转为浮点数，即 parseFloat()

RE( flag: String ): RegExp
// 将字符串转为正则表达式。

Bool( all:Boolean ): Boolean
// 转换为布尔值（false|true）
// 假值：'', 0, false, null, undefined
// 如果传递all为真，假值包含 [], {}。

Str( prefix?, suffix? ): String
// 转换为字符串。
// 可以选择性的添加前/后缀。

Arr( one: Boolean ): Array
// 转换为数组。
// 类数组才会被转换为一个真正的数组（Array.from）。
// 如果要强制打包目标为一个单成员数组（Array.of），可传递one为真。

Obj(): Object
// 将目标转换为普通对象。
// 目标可以是数组、Set或Map实例，主要针对有entries接口的对象。
// 注：内部调用 Object.fromEntries()。



// 简单值操作。
//===============================================

push( ...val: Value|[Value] ): void
// 直接赋值入栈。
// 目标：当前条目，可选。
// 特权：是，自行入栈。
// 多个实参会自动展开入栈，数组实参视为单个值。
// 如果实参和目标都有值，则目标作为单一值附加在实参序列之后。

env( names: String, its?: Value|String ): void|Value
// 全局环境设置/取值。
// 目标：当前条目，可选。
// 目标非空或its有值时为设置，否则为取值入栈。
// 设置时：
// - 目标为空：取its本身为值（必然存在）。
// - 目标非空：取目标的its属性值或目标本身（its未定义时）。
// 注：
// its支持空格分隔多个名称指定目标属性。

sess( name: String|null, its?: Value|String|null): void|Value
// 设置/取值浏览器会话数据（sessionStorage）。
// 目标：当前条目，可选。
// 目标为空且its未定义时为取值入栈，否则为设置。
// 说明：
// 参考evn指令，但name仅支持单个名称。
// its依然可为键名序列，从目标上提取一个值集（对应到单个name）。
// 传递its为null可清除name项的值，传递name为null可清除整个Storage存储。
// 注：
// 存储的值会被转换为字符串，取出的值也为字符串。

local( name: String|null, its?: Value|String|null): void|Value
// 设置/取值浏览器本地数据（localStorage）。
// 目标：当前条目，可选。
// 说明：参考sess指令。

get( ...names: String ): Value|[Value]
// 取目标成员值入栈。
// 目标：当前条目/栈顶1项。
// 特权：是，自行入栈。
// name支持空格分隔的多个名称，此时值为一个集合（不展开）。
// 多个实参名称取值会自动展开入栈。
// 注意：
// 实参名称不要有多余的空格，否则前后空串也是一个键名。

call( meth, ...rest ): Value
// 调用目标的方法，执行结果入栈。
// 目标：当前条目/栈顶1项。


$if( val, elseval? ): Value
// 条件赋值。
// 目标：当前条目/栈顶1项。
// 如果目标值为真（广义），val入栈，否则入栈elseval。
// elseval值可选，如果未定义则为简单的if逻辑。

$case( ...vals ): [Boolean]
// 分支比较。
// 目标：当前条目/栈顶1项。
// 目标与实参一一相等（===）比较，结果入栈。
// 这是$switch指令的前阶执行。

$switch( ...vals ): Value
// 分支判断赋值。
// 目标：当前条目/栈顶1项。
// 取栈顶通常是$case执行的结果（一个集合），
// 测试集合成员值是否为真（广义），真值返回相同下标实参值入栈。
// 注：
// 仅取首个真值对应的实参值入栈。
// 目标集大小通常与实参序列长度相同，但容许超出（被简单忽略）。
// 目标应当是一个数组（.entries接口）。



// 集合操作。
// 注：大部分接口作为tQuery调用定义在On部分。
//===============================================

array( size, ...vals ): Array
// 创建预填充值的数组（size大小）。
// 目标：当前条目，可选。
// 如果目标有值，会合并到实参序列之后填充。
// 如果size大于预填充值集合，最后一个值重复填充至最后。
// 注：
// 当前条目如果是数组，会解构填充。
// 如果完全没有填充值，数组成员会填充为undefined。

keys(): [Value]
// 调用目标 .keys() 接口构造为值数组。
// 注：也适用普通对象（Object）。

values(): [Value]
// 调用目标 .values() 接口构造为值数组。
// 注：也适用普通对象（Object）。

join( chr ): String
// 调用目标的 .join() 方法构造字符串。
// 主要用于数组成员的连接。
// 注：即 .call('join', chr) 的特例版。

concat( ...vals ): [Value]
// 数组串接。
// 目标：当前条目/栈顶1-2项。
// 特权：是，灵活取栈。
// 如果实参为空，取栈顶2项，否则取1项。
// 实参可以是一个值或数组。

split( sep ): [String]
// 切分字符串为数组。
// 目标：当前条目/栈顶1项。
// 内容：必须为字符串。



// 简单运算。
// 支持前一个操作数是数组的情况（取成员计算）。
//===============================================

add( val?:Number ): Number|String|[...] // (x, y) => x + y
sub( val?:Number ): Number|[Number]     // (x, y) => x - y
mul( val?:Number ): Number|[Number]     // (x, y) => x * y
div( val?:Number ): Number|[Number]     // (x, y) => x / y
mod( val?:Number ): Number|[Number]     // (x, y) => x % y
pow( val?:Number ): Number|[Number]     // (x, y) => x ** y
// 标准算术。
// 目标：当前条目/栈顶1-2项。
// val 第二个操作数，可选。

divmod( val?:Number ): [Number, Number]
// 除并求余。(x, y) => [x/y, x%y]
// 目标：当前条目/栈顶2项。
// 注：
// 商数取小于等于结果的整数值。
// 如：3.5 => 3, -3.5 => -4

neg(): Number|[Number]
// 数值取负（-x）。
// 目标：当前条目/栈顶1项。
// 支持目标为集合，对成员分别取负。

vnot(): Boolean|[Boolean]
// 逻辑取反（!x）。
// 目标：当前条目/栈顶1项。
// 支持目标为集合，对成员分别取反。



// 克隆创建
//===============================================

dup( n = 1 ): Value | [Value]
// 栈顶浅复制。
// 目标：可选当前条目为克隆数（不自动取栈）。
// 特权：是。多条目克隆压入。
// 若当前条目有值，视为复制数量。
// 无参数调用时，n默认取1。
// 附：
// 效果与 `slice(-n) spread` 相同。

clone( event, deep, eventdeep ): Element | Collector
// 专用：元素克隆。
// 目标：当前条目/栈顶1项。
// 注：兼容集合处理。

assign( target:Object, names?:String ): Object
// 对象克隆赋值。
// 目标：当前条目/栈顶1项。
// 目标为数据源，克隆仅限于对象自身的可枚举属性。
// names为目标属性名清单，空格分隔多个名称。
// 如果names未定义，克隆源对象自身的全部可枚举属性（含Symbol）。

gather( names: String ): Object
// 集合映射聚集。
// 目标：当前条目/栈顶1项
// names支持空格分隔的多个名称，把集合成员映射到一个键值对对象。
// 集合通常是数组（也支持字符串），按名称顺序下标取值作为该键名对应的值。
// 集合大小通常与名称数量一致，若不足，则值为undefined。



// 比较运算
// 目标：当前条目/栈顶2项。
//===============================================

equal(): Boolean    // (x, y) => x === y
nequal(): Boolean   // (x, y) => x !== y
lt(): Boolean       // (x, y) => x < y
lte(): Boolean      // (x, y) => x <= y
gt(): Boolean       // (x, y) => x > y
gte(): Boolean      // (x, y) => x >= y

arrayEqual( arr? )
// 数组相等比较。
// 如果传递 arr 实参则取栈顶1项比较，否则取栈顶两项比较。
// 目标：当前条目/栈顶1-2项。
// 特权：是，需要灵活取栈条目。
// 注：
// 仅对数组的成员逐一执行浅相等对比。

contains(): Boolean
// 元素包含测试。
// $.contains( box, sub )


// 逻辑运算
//===============================================

within( min, max ): Boolean
// 目标是否在 [min, max] 的范围内（包含边界值）。
// 目标：当前条目/栈顶1项。

include( ...vals ): Boolean
// 目标是否在实参序列内。
// 目标：当前条目/栈顶1项。
// 实现：Array.includes。

both(): Boolean
// 二者为真（广义）判断。
// 目标：当前条目/栈顶2项。

either(): Boolean
// 二者任一为真测试。
// 目标：当前条目/栈顶2项。

every( expr ): Boolean
// 集合成员全为真测试。
// expr 可选，默认简单真值判断。
// 目标：当前条目/栈顶1项。
// 表达式接口：function(v, i, o): Boolean。
// 注：目标必须是一个集合。

some( expr ): Boolean
// 集合成员至少1项为真测试。
// expr 可选，默认简单真值判断。
// 目标：当前条目/栈顶1项。
// 表达式接口：function(v, i, o): Boolean。
// 注：目标必须是一个集合。

inside( name: String, val: Value|[Value] ): Boolean
// 目标对象内成员测试。
// 目标：当前条目/栈顶1项。
// name为属性名，支持空格分隔的多个属性名指定。
// val为对比值，用于与目标属性值做全等比较。可选，默认为存在性测试（非undefined）。
// 如果name为多名称指定，val可以是一个数组（一一对应）或undefined。
// 当所有的检查/比较都为真时，返回true。
// 例：
// inside('shift ctrl', true)
// 检查目标内shift和ctrl成员值是否都为真。
// inside('selector')
// 检查目标内的selector成员是否存在（非undefined）。
// inside('AA BB', [1, 2])
// 检查目标内是否：AA成员值为1且BB成员值为2。



// 增强运算
//===============================================

func( ...argn: String ): Function
// 创建函数入栈。
// 取目标为函数体表达式（无需return）。
// 目标：当前条目/栈顶1项。
// 可以传递函数的参数名序列。

exec( ...rest ): Value
// 把目标视为函数，传递实参执行后结果入栈。
// 目标：当前条目/栈顶1项。
// 注：通常配合 func 使用。

calc( expr ): Value
// 表达式计算。
// 目标：当前条目/栈顶1项。
// 用$引用目标数据，计算表达式（无需return）的值。
// 例：
// calc('($[0] + $[1]) * $[2]')
```



## 应用

### 交互文档

最简单的形式，让普通网页包含互动，不涉及向服务器请求新的数据。适合普通的离线文档手册等。


### 动态页（By:pull）

需要联网，页面向服务器实时请求数据更新内容，页面展示逻辑较为简单（通常不涉及模板渲染）。


### 页程序（x.[myApp].run(...); x.[myApp].[meth]; x.[myApp].[meth].[...]）

功能复杂的页面应用，向服务器提交的请求较为多样，返回的数据需要再处理以符合展示逻辑。通常需要模板支持，逻辑被分解为 `CMV`（`Control/Model/View`） 三个层次。

当然，纯本地的复杂JS应用也可以采用这种分层结构。



## 附录

### 缩写

> `OBT`: `On-By-To` 在HTML页面中定义行为。
> `CMV`: `Control, Model, View` 复杂App的业务切分（三层）。


### 模板特殊字符

在模板中部分标点符号用于特别的目的。

- **`;`** 分号。分隔符，用于通用的逻辑区隔，如OBT定义分组。
- **`_`** 空格（Space）。指令序列的分隔字符。
- **`,`** 逗号。实参序列的分隔符。
- **`|`** 竖线。递进处置，如输出数据的过滤处理、事件关联的行为链。
- **`-`** 横线。空值占位，主要用于OBT分组定义中的顺序保持。
- **`$`** 对当前域或父域对象的引用。
