# 文章内容的规范化结构

文章的内容最多分为五个层级：**章**、**节**、**区**、**段**、**末**，每一层级对应一个 `<section>`，其中首个元素为标题（`<h2>` ~ `<h6>`）。**章**的标题为 `<h2>`，**节**的标题为 `<h3>`，其余类推。`<h1>` 用于文章自身的主标题，不作为内容层次结构里的组成。

文章用 `<article>` 元素包含，是全部内容结构的根元素。

本设计试图规范化大部分文章的内容结构，让样式文件可以共享。精美的样式会让阅读体验更好，共享的样式则可以让文章作者免除负担，专注于内容。



## 内容的结构

逐级嵌套的结构按标题号递减（数字递增），逻辑上是越来越细化的片区。本设计借鉴了Markdown文档按标题折叠的逻辑，因此也便于从Markdown文档直接简单转换过来。

> **注：**<br>
> 根据使用经验，这种规范的结构有助于合理地组织内容，实现更清晰的表达。


### 层次图

```html
<article> <h1></h1>                                 <!-- 根容器/主标题 -->
    <header role="abstract"></header>               <!-- 提要 -->
    <nav role="toc" class="toc"></nav>              <!-- 目录 -->
    <header></header>                               <!-- 章导言 -->
    <section>                                       <!-- 章片区。第一层 section -->
        <h2></h2>                                   <!-- 章标题 -->
        <header></header>                           <!-- 节导言 -->
        <section>                                   <!-- 节片区。第二层 section -->
            <h3></h3>                               <!-- 节标题 -->
            <header></header>                       <!-- 区导言 -->
            <section>                               <!-- 区片区。第三层 section -->
                <h4></h4>                           <!-- 区标题 -->
                <header></header>                   <!-- 段导言 -->
                <section>                           <!-- 段片区。第四层 section -->
                    <h5></h5>                       <!-- 段标题 -->
                    <header></header>               <!-- 末导言 -->
                    <section>                       <!-- 末片区。第五层 section -->
                        <h6></h6>                   <!-- 末标题 -->
                        <section role="content">    <!-- 内容/正文区 -->
                            [内容单元] ...
                        </section>
                    </section>
                    ...                             <!-- 平级 section/h6 -->
                    <footer></footer>               <!-- 末结语 -->
                </section>
                ...                                 <!-- 平级 section/h5 -->
                <footer></footer>                   <!-- 段结语 -->
            </section>
            ...                                     <!-- 平级 section/h4 -->
            <footer></footer>                       <!-- 区结语 -->
        </section>
        ...                                         <!-- 平级 section/h3 -->
        <footer></footer>                           <!-- 节结语 -->
    </section>
    ...                                             <!-- 平级 section/h2 -->
    <footer></footer>                               <!-- 章结语 -->
    <hr />                                          <!-- 章间隔 -->
    <ul role="seealso"></ul>                        <!-- 另参见 -->
    <ol role="references"></ol>                     <!-- 文献参考 -->
</article>
```

**解析逻辑：**

1. 在文本格式的 `markdown` 中，每一级标题之后的内容即为该标题所属 `<section>` 的内容。
2. 在内容之中可以包含层级更低的标题，如果出现更低层级的下级标题，在首个下级标题之前的内容被视为 `<header>`。
3. 如果内容中已经没有下级标题，则视为正文部分，由 `<section role="content">` 包含，它被称为 `正文区`。
4. 如果下级标题不是顺次递减而是跨级，则也被视为正文区，但内部子标题继续解析。这违反了标准的层次结构，通常是内容组织不够合理的表现。
5. 因此，除了正文区外，一个层级中最多只会包含3种单元：标题（`h2-h6`）、导言（`header`）、一个或多个下级 `<section>`。

> **注：**<br>
> 对于缺乏明确标签表达的内容逻辑，采用相似用途的标签和 `role` 属性来定义，如 `<nav role="toc">` 表示目录。<br>
> 在实际的 `HTML` 文档里会添加一个与 `role` 同值的 `class` 属性，便于 `CSS` 简单定位引用。<br>



## 内容的组成

### 行块单元

块单元会占据单独的一行，在CSS中的显示属性是 `display:block`（注：`display:inline-block` 作为行内单元对待）。块单元又分为两种，一种是需要包含其它子元素的**结构类**单元，一种是可以直接包含文本的**文本类**容器。

行块单元是独立的**内容单元**，它们可以自由地存在于内容容器（如 `<section role="content">`）中，同一父容器下的内容单元可以平级自由移动。


#### 结构类

内部不能直接包含文本或内联元素，如果没有标准的内部子结构，通常采用段落 `<p>` 元素来包含主体文本。

```html
<!--                                     说明：Name -->
<header role="abstract"></header>   <!-- 提要：Abstract /h3, p... -->
<nav role="toc"></nav>              <!-- 目录：Toc /h4, ol/li/a（可多级） -->
<header></header>                   <!-- 导言：Header /h4, p... -->
<footer></footer>                   <!-- 结语：Footer /h4, p... -->
<section role="s1"></section>       <!-- 片区：S1 /section/h2, ... -->
<section role="s2"></section>       <!-- 片区：S2 /section/h3, ... -->
<section role="s3"></section>       <!-- 片区：S3 /section/h4, ... -->
<section role="s4"></section>       <!-- 片区：S4 /section/h5, ... -->
<section role="s5"></section>       <!-- 片区：S5 /section/h6, ... -->
<section role="content"></section>  <!-- 正文区：Content /[^hx, section]... -->
<ul></ul>                           <!-- 无序列表：Ul /li/... -->
<ul role="seealso"></ul>            <!-- 另参见：Seealso /li/... -->
<ol></ol>                           <!-- 有序列表：Ol /li/... -->
<ol role="cascade"></ol>            <!-- 多级编号列表：Cascade /li/h5, ol, ... -->
<ol role="codelist"></ol>           <!-- 代码表：Codelist /li/code/b, #text -->
<ol role="references"></ol>         <!-- 文献参考：References /li/... -->
<dl></dl>                           <!-- 定义列表：Dl /dt, dd/... -->
<table></table>                     <!-- 表格：Table /caption, thead, tbody, tfoot/tr/td/... -->
<figure></figure>                   <!-- 插图：Figure /figcaption, p... -->
<blockquote></blockquote>           <!-- 引用块：Blockquote /h4, p... -->
<aside></aside>                     <!-- 批注：Aside /h4, p... -->
<details></details>                 <!-- 详细内容：Details /sumary, p... -->
<pre role="codeblock"></pre>        <!-- 代码块：Codeblock /code/b, #text -->
```


#### 文本类

可直接包含文本内容，同时脱离固定的DOM结构且单独占据一整行的块级容器元素。线条作为内容特例也划归为文本类，因为它就是内容本身。

```html
<p></p>                     <!-- 段落：P 通用内容容器 -->
<address></address>         <!-- 地址信息：Address -->
<pre></pre>                 <!-- 预排版：Pre 非代码块 -->
<hr />                      <!-- 线条：Hr 特例 -->
<div role="space"></div>    <!-- 空白块：Space 可用于交互展示 -->
```

> **概念：**<br>
> **内容元素**：指可以直接包含文本或其它内联元素，或其本身就是内容实体（`<img>`）的元素。<br>
> **内容单元**：指作为内容实体的行块单元，部分内容单元是内容元素，但两者的概念不同。如 `<li>` 和 `<td>` 都是内容元素但不是内容单元。<br>


### 行内单元

只能被包含在内容元素里，即通常所说的内联（`inline`）元素。

它们不能作为独立的行块出现在内容容器（如 `<section role="content">`）中，即：它们不属于**内容单元**，它们必须被文本类行块单元封装才能成为内容单元。大部分内联元素属于内容元素。

```html
<!--                             说明：Name -->
<audio></audio>             <!-- 音频：Audio /track,source, #text -->
<video></video>             <!-- 视频：Video /track,source, #text -->
<picture></picture>         <!-- 图片：Picture /source,img -->
<a></a>                     <!-- 链接：A -->
<strong></strong>           <!-- 重点：Strong -->
<em></em>                   <!-- 强调：Em -->
<q></q>                     <!-- 短引用：Q -->
<abbr></abbr>               <!-- 缩写：Abbr -->
<cite></cite>               <!-- 来源：Cite -->
<small></small>             <!-- 注脚：Small -->
<time></time>               <!-- 时间：Time -->
<del></del>                 <!-- 删除：Del -->
<ins></ins>                 <!-- 插入：Ins -->
<sub></sub>                 <!-- 下标：Sub -->
<sup></sup>                 <!-- 上标：Sup -->
<mark></mark>               <!-- 标记：Mark -->
<code></code>               <!-- 代码：Code -->
<code role="orz"></code>    <!-- 表情：Orz -->
<ruby></ruby>               <!-- 注音：Ruby /rb,rp,rt -->
<dfn></dfn>                 <!-- 定义：Dfn -->
<samp></samp>               <!-- 样本：Samp -->
<kbd></kbd>                 <!-- 键盘字：Kbd -->
<s></s>                     <!-- 失效：S -->
<u></u>                     <!-- 注记：U -->
<var></var>                 <!-- 变量：Var -->
<bdo></bdo>                 <!-- 文本方向：Bdo -->
<meter></meter>             <!-- 度量：Meter -->
<b>                         <!-- 粗体：B 主要用于代码块内的关键字包裹 -->
<i>                         <!-- 斜体：I 主要用于图标占位（icon） -->
<img />                     <!-- 图片：Img -->
<span role="blank"></span>  <!-- 空白段：Blank -->
#text                       <!-- 文本节点：#text -->
```



## 内容的类型

```js
{
// 结构单元
// BLOTHS：table|hr|space
// BLOUFCPC：ul|figure|codelist|pre|codeblock
Abstract:   'ABSTRACT',
Toc:        'TOC',
Header:     'HEADER',
Footer:     'FOOTER',
S1:         'S1',
S2:         'S2',
S3:         'S3',
S4:         'S4',
S5:         'S5',
Content:    'CONTENT',
Ol:         'OL',
Ul:         'BLOUFCPC', // 基本块（ul, figure, codelist, pre, codeblock）
Seealso:    'SEEALSO',
Cascade:    'CASCADE',
Codelist:   'BLOUFCPC',
References: 'REFERENCES',
Dl:         'DL',
Table:      'BLOTHS',   // 基本块（table, hr, space）
Figure:     'BLOUFCPC',
Blockquote: 'BLOCKQUOTE',
Aside:      'ASIDE',
Details:    'DETAILS',
Codeblock:  'BLOUFCPC',

// 文本单元
P:          'P',
Address:    'ADDRESS',
Pre:        'BLOUFCPC',
Hr:         'BLOTHS',
Space:      'BLOTHS',

// 限定中间单元
Cascadetoc: 'CASCADETOC',   // Toc: cascade/li/a
Ali:        'ALI',          // Toc: li/a
Codeli:     'CODELI',       // Codelist: li/code
Cascadeli:  'CASCADELI',    // Cascade: li/h5, ol

// 内联单元。
// 取值时会提取元素本身，因此配置为同一类。
Audio：     'INLINE',
Video：     'INLINE',
Picture：   'INLINE',
Strong：    'INLINE',
Em：        'INLINE',
Q：         'INLINE',
Abbr：      'INLINE',
Cite：      'INLINE',
Small：     'INLINE',
Time：      'INLINE',
Del：       'INLINE',
Ins：       'INLINE',
Sub：       'INLINE',
Sup：       'INLINE',
Mark：      'INLINE',
Orz：       'INLINE',
Ruby：      'INLINE',
Dfn：       'INLINE',
Samp：      'INLINE',
Kbd：       'INLINE',
S：         'INLINE',
U：         'INLINE',
Var：       'INLINE',
Bdo：       'INLINE',
Meter：     'INLINE',
Blank:      'INLINE',

// 会被作为特定的子单元使用。
A：         'A',
Code：      'CODE',
Img：       'IMG',
I：         'I',
B：         'B',
#text:      '$TEXT',


// 简单元素
// 名称保持元素小写标签名。
h2:         'H2',
h3:         'H3',
h4:         'H4',
h5:         'H5',
h6:         'H6',
summary:    'SUMMARY',
figcaption: 'FIGCAPTION',
li:         'LI',
dt:         'DLI',
dd:         'DLI',

rb:         'RBPT',
rp:         'RBPT',
rt:         'RBPT',
track:      'TRACK',
source:     'SOURCE',

// 表格单独处理。
caption:    'CAPTION',
thead:      'TSEC',
tbody:      'TSEC',
tfoot:      'TSEC',
tr:         'TR',
th:         'TCELL',
td:         'TCELL',
}
```


### 合法子类型

每个结构性元素或内容单元的子单元类型都是有限定的。插入节点内容时会考虑：

1. 目标参考元素的父元素允许哪些子单元？符合即简单插入，否则检查是否需要/可以转换？
2. 目标参考元素自身作为容器允许哪些子单元，符合即简单添加，否则检查是否需要/可以转换？

> **注：**<br>
> 转换时通常是创建一个默认的空子单元，然后提取源数据填充。<br>
> 空的子类型表示不能直接插入内容，需使用其特有的接口操作。<br>


```js
{
Abstract:   [ H3, P, BLOTHS ],
Toc:        [ H4, CASCADETOC ],
Header:     [ H4, P, BLOTHS ],
Footer:     [ H4, P, BLOTHS, BLOCKQUOTE, SEEALSO, REFERENCES, ADDRESS ],
S1:         [ H2, HEADER, S2, FOOTER ],   // 注：对Content为转换检测。
S2:         [ H3, HEADER, S3, FOOTER ],   // 注： 同上
S3:         [ H4, HEADER, S4, FOOTER ],   // 注： 同上
S4:         [ H5, HEADER, S5, FOOTER ],   // 注： 同上
S5:         [ H6, HEADER, CONTENT, FOOTER ],
Content:    [ P, BLOTHS, OL, BLOUFCPC, DL, BLOCKQUOTE, ASIDE, DETAILS, CASCADE, ADDRESS ],
Ul:         [ LI ],
Seealso:    [ LI ],
Ol:         [ LI ],
Cascade:    [ CASCADELI ],
Codelist:   [ CODELI ],
References: [ LI ],
Dl:         [ DLI ],
Table:      [ CAPTION, TSEC ],
Figure:     [ FIGCAPTION, P ],
Blockquote: [ H4, P, BLOTHS, OL, BLOUFCPC, BLOCKQUOTE ],
Aside:      [ H4, P, BLOTHS, OL, BLOUFCPC, BLOCKQUOTE, ADDRESS ],
Details:    [ SUMMARY, P, BLOTHS, OL, BLOUFCPC, BLOCKQUOTE ],
Codeblock:  [ CODE ],   // pre/code

// 文本类行块。
P:          [ $TEXT, INLINE, CODE, IMG ],
Address:    [ $TEXT, INLINE, CODE, IMG ],
Pre:        [ $TEXT, INLINE, CODE, IMG ],
Hr:         [], // 空
Space:      [], // 空，用于交互展示

// 限定中间结构
Cascadetoc: [ ALI ],
Ali:        [ A ],
Codeli:     [ CODE ],
Cascadeli:  [ H5, OL ]

// 内联单元
Audio:      [ TRACK, SOURCE ],  // 文本仅初始构造时包含，不支持后期注入
Video:      [ TRACK, SOURCE ],  // 同上
Picture:    [ SOURCE, IMG ],
A:          [ $TEXT, INLINE, IMG ],
Strong:     [ $TEXT, INLINE ],
Em:         [ $TEXT, INLINE ],
Dfn:        [ $TEXT, INLINE ],
Abbr:       [ $TEXT ],
Time:       [ $TEXT ],
Kbd:        [ $TEXT ],  // 键盘输入
Var:        [ $TEXT ],  // 变量标注
Code:       [ $TEXT, B ],
Orz:        [ $TEXT ],
Meter:      [ $TEXT ],  // 范围计量
Ruby:       [ RBPT, $TEXT ],
Q:          [ $TEXT, INLINE, A ],
Small:      [ $TEXT, INLINE, A ],
Samp:       [ $TEXT, INLINE, A ],   // 计算机输出
U:          [ $TEXT, INLINE, A ],   // 特别标注
Bdo:        [ $TEXT, INLINE, A ],
Cite:       [ $TEXT, INLINE, A ],
Del:        [ $TEXT, INLINE, A ],
Ins:        [ $TEXT, INLINE, A ],
S:          [ $TEXT, INLINE, A ],
Sub:        [ $TEXT, INLINE, A ],
Sup:        [ $TEXT, INLINE, A ],
Mark:       [ $TEXT, INLINE, A ],
B:          [ $TEXT ],  // 简单支持
I:          [ $TEXT ],  // 同上

Img:        [], // 空
Blank:      [], // 空，用于交互展示

// 定制中间结构
// 注：I 可用于标题序号或背景按钮。
h2:         [ $TEXT, INLINE, I, A ],
h3:         [ $TEXT, INLINE, I, A ],
h4:         [ $TEXT, INLINE, I, A ],
h5:         [ $TEXT, INLINE, I, A ],
h6:         [ $TEXT, INLINE, I, A ],
figcaption: [ $TEXT, INLINE, I, A ],
summary:    [ $TEXT, INLINE, CODE, I, A ],
li:         [ $TEXT, INLINE, CODE, IMG, A ],
dt:         [ $TEXT, INLINE, CODE, I, A ],
dd:         [ $TEXT, INLINE, CODE, IMG, A ],

// 原生中间结构。
caption:    [ $TEXT, INLINE, I, A ],
thead:      [ TR ],
tbody:      [ TR ],
tfoot:      [ TR ],
tr:         [ TCELL ],
th:         [ $TEXT, INLINE, I, A ],
td:         [ $TEXT, INLINE, CODE, I, IMG, A ],

rb:         [ $TEXT ],
rp:         [ $TEXT ],
rt:         [ $TEXT ],
track:      [], // 空，单标签
source:     [], // 空，同上
}
```


## 单元结构

内容单元是独立完整的区块，普通区块如果有标题，采用 `<h4>` 级别。文章摘要属于顶层区块，标题采用 `<h3>` 级别。


### 原生结构

#### 导言

```html
<header>
    <h4></h4> <!-- 可选 -->
    <p></p> ...
</header>
```


#### 片区

```html
<section>
    <h2> ~ <h6>         <!-- 标题 -->
    <header></header>   <!-- 导言：可选 -->
    <section></section> <!-- 子片区或正文区 -->
    <footer></footer>   <!-- 结语：可选 -->
</section>
```


#### 结语

```html
<footer>
    <h4></h4> <!-- 可选 -->
    <p></p> ...
</footer>
```


#### 无序列表

```html
<ul>
    <li></li>
</ul>
```


#### 有序列表

```html
<ol>
    <li></li>
</ol>
```


#### 定义列表

```html
<dl>
    <dt></dt>
    <dd></dd>
</dl>
```


#### 表格

```html
<table>
    <caption></caption>
    <thead> <!-- 可选 -->
        <tr><td></td></tr>
    </thead>
    <tbody>
        <tr><td></td></tr>
    </tbody>
    <tfoot> <!-- 可选-->
        <tr><td></td></tr>
    </tfoot>
</table>
```


#### 插图

```html
<figure>
    <figcaption></figcaption>
    <p>
        <img />...
    <p>
</figure>
```


#### 详细内容

从内容逻辑和浏览器的视觉实现上看，本区块的摘要（标题）与内容有明显的区隔，因此内容部分采用单独的容器封装（而不是平级罗列）。

```html
<details>
    <summary></summary>
    <section role="content">
        [内容单元]...
    </section>
</details>
```


#### 引用块

```html
<blockquote>
    <h4></h4>   <!-- 可选 -->
    <p><p> ...  <!-- 平级罗列 -->
</blockquote>
```


#### 批注

```html
<aside>
    <h4></h4> <!-- 可选 -->
    <p><p> ...
</aside>
```



#### 代码块

```html
<pre><!-- 容许简单换行 -->
<code data-lang="xx"> ...<b></b>...
</code><pre> <!-- 末尾应当紧跟 -->
```


#### 注音

```html
<ruby>
    <rb>漢</rb><rp>（</rp><rt> ㄏㄢˋ </rt><rp>）</rp>
</ruby>
```


### 定制结构

#### 摘要

```html
<header role="summary" class="summary">
    <h3>摘 要</h3>
    <p></p> ...
</header>
```

#### 目录

```html
<nav role="toc" class="toc">
    <h4></h4>
    <ol role="cascade" class="cascade">
        <li><a href="#..."></a></li>
    </ol>
</nav>
```

#### 正文区

```html
<section role="content" class="content">
    [块单元内容]... <!-- 不含其它片区<section> -->
</section>
```

#### 多级编号列表

```html
<ol role="cascade" class="cascade">
    <li></li> <!-- 由CSS表达序号规则 -->
    <li><h5></h5> ...
        <ol>
            <li></li>
        </ol>
    </li>
</ol>
```

#### 代码表

```html
<ol role="codelist" class="codelist">
    <li><code data-lang="xx"> <!-- 根封装 -->
        ...<b></b>... <!-- 代码内容，<b>着色封装 -->
    </code></li>
    <li><code data-lang="xx"> ... </code></li>
</ol>
```

**注**：所有代码的data-lang属性仅设置在 `<code>` 元素上。


## 代码着色

### 封装规则

考虑简单性，代码内的高亮着色采用 `<b>` 元素封装，通过 `class` 类名区分。所有 `<b>` 元素只会处于同一层级（`<code>` 直接子元素），没有嵌套。

基本类名定义如下：

```css
b.cmt   /* comments */
b.str   /* string */
b.kws   /* keywords */
b.tag   /* tag-name */
b.slr   /* selector */
b.atn   /* attribute-name */
b.atv   /* attribute-value */
b.fun   /* function-work */
b.typ   /* data-type */
b.imp   /* important */
b.doc   /* <!DOCTYPE...> */
b.cdt   /* <![CDATA[...]]> */
b.rex   /* js-RegExp */
b.non   /* invalid */
```

### 示例

#### 源码1（代码块）

```html
<pre>
<code data-lang="go"><b class="cmt">// prints its command-line arguments.</b>
<b class="kws">package</b> main

<b class="kws">import</b> (
    <b class="str">"fmt"</b>
    <b class="str">"os"</b>
)

<b class="kws">func</b> main() {
    <b class="kws">var</b> s, sep <b class="typ">string</b>
    <b class="kws">for</b> i := 1; i &lt; <b class="fun">len</b>(os.Args); i++ {
        s += sep + os.Args[i]
        sep = <b class="str">" "</b>
    }
    fmt.Println(s)
}</code></pre>
```

#### 效果

```go
// Echo1 prints its command-line arguments.
package main

import (
    "fmt"
    "os"
)

func main() {
    var s, sep string
    for i := 1; i < len(os.Args); i++ {
        s += sep + os.Args[i]
        sep = " "
    }
    fmt.Println(s)
}
```

#### 源码2（代码表）

```html
<ol role="codelist" class="codelist">
    <li><code data-lang="go"><b class="kws">package</b> main</code></li>
    <li><code data-lang="go"><b class="kws">import</b> <b class="str">"fmt"</b></code></li>
    <li><code data-lang="go"><b class="kws">func</b> main() {</code></li>
    <li><code data-lang="go">    fmt.Println(<b class="str">"Hello, 世界"</b>) <b class="cmt">// 通过导入的 fmt 包，执行 Println 函数向控制台打印消息。</b></code></li>
    <li><code data-lang="go">}</code></li>
    <li><code data-lang="go"><b class="kws">type</b> MapSort <b class="kws">struct</b> {</code></li>
    <li><code data-lang="go">    m <b class="kws">map</b>[<b class="typ">string</b>]<b class="typ">int</b></code></li>
    <li><code data-lang="go">    s []<b class="typ">string</b></code></li>
    <li><code data-lang="go">}</code></li>
</ol>
```

#### 效果

```go
package main
import "fmt"
func main() {
    fmt.Println("Hello, 世界") // 通过导入的 fmt 包，执行 Println 函数向控制台打印消息。这是一个长行。
}
type MapSort struct {
    m map[string]int
    s []string
}
```

**注**：html页面中实际会显示行号。
