# 文章内容的规范化结构

文章的内容最多分为五个层级：**章**、**节**、**区**、**段**、**末**，每一层级对应一个 `<section>`，其中首个元素为标题（`<h2>` ~ `<h6>`）。**章**的标题为 `<h2>`，**节**的标题为 `<h3>`，其余类推。`<h1>` 用于文章自身的主标题，不作为内容层次结构里的组成。

文章用 `<article>` 元素包含，是全部内容结构的根元素。

本设计试图规范化大部分文章的内容结构，让样式文件可以共享。精美的样式会让阅读体验更好，共享的样式则可以让文章作者免除负担，专注于内容。



## 内容的结构

逐级嵌套的结构按标题号递减（数字递增），逻辑上是越来越细化的片区。本设计借鉴了Markdown文档按标题折叠的逻辑，因此也便于从Markdown文档直接简单转换过来。

> **注：**<br>
> 根据使用经验，这种规范的结构有助于合理地组织内容，实现更清晰的表达。


### 层次图

```html
<h1></h1>                                   <!-- 主标题 -->
<header role="abstract"></header>           <!-- 提要 -->
<nav role="toc" class="toc"></nav>          <!-- 目录 -->
<article>                                   <!-- 文章区 -->
    <header></header>                       <!-- 章导言 -->
    <h2></h2>                               <!-- 章标题 -->
    <section role="s1">                     <!-- 章片区。第一层 section -->
        <header></header>                   <!-- 节导言 -->
        <h3></h3>                           <!-- 节标题 -->
        <section role="s2">                 <!-- 节片区。第二层 section -->
            <header></header>               <!-- 区导言 -->
            <h4></h4>                       <!-- 区标题 -->
            <section role="s3">             <!-- 区片区。第三层 section -->
                <header></header>           <!-- 段导言 -->
                <h5></h5>                   <!-- 段标题 -->
                <section role="s4">         <!-- 段片区。第四层 section -->
                    <header></header>       <!-- 末导言 -->
                    <h6></h6>               <!-- 末标题 -->
                    <section role="s5">     <!-- 末片区。第五层 section -->
                        [ Text ] ...        <!-- 正文内容 -->
                    </section>
                    ...                     <!-- 平级 h6/section -->
                    <footer></footer>       <!-- 末结语 -->
                </section>
                ...                         <!-- 平级 h5/section -->
                <footer></footer>           <!-- 段结语 -->
            </section>
            ...                             <!-- 平级 h4/section -->
            <footer></footer>               <!-- 区结语 -->
        </section>
        ...                                 <!-- 平级 h3/section -->
        <footer></footer>                   <!-- 节结语 -->
    </section>
    <hr />                                  <!-- 章间隔 -->
    ...                                     <!-- 平级 h2/section -->
    <footer></footer>                       <!-- 章结语 -->
</article>
<ul role="seealso"></ul>                    <!-- 另参见 -->
<ol role="references"></ol>                 <!-- 文献参考 -->
```

**解析逻辑：**

1. 在文本格式的 `markdown` 中，每一级标题之后的内容即为该标题所属 `<section>` 的内容。
2. 在内容之中可以包含层级更低的标题，如果出现更低层级的下级标题，在首个下级标题之前的内容被视为 `<header>`。
3. 如果内容中已经没有下级标题，则视为正文部分，由 `<section role="content">` 包含，它被称为 `正文区`。
4. 如果下级标题不是顺次递减而是跨级，则也被视为正文区，但内部子标题继续解析。这违反了标准的层次结构，通常是内容组织不够合理的表现。
5. 因此，除了正文区外，一个层级中最多只会包含3种单元：标题（`h2-h6`）、导言（`header`）、一个或多个下级 `<section>`。

> **注：**<br>
> 对于缺乏明确标签表达的内容逻辑，采用相似用途的标签和 `role` 属性来定义，如 `<nav role="toc">` 表示目录。<br>
> 在实际的 `HTML` 文档里会添加一个与 `role` 同值的 `class` 属性，便于 `CSS` 简单定位引用。<br>



## 内容的组成

### 行块单元

块单元会占据单独的一行，在CSS中的显示属性是 `display:block`（注：`display:inline-block` 作为行内单元对待）。块单元又分为两种，一种是需要包含其它子元素的**结构类**单元，一种是可以直接包含文本的**文本类**容器。

行块单元是独立的**内容单元**，它们可以自由地存在于内容容器（如 `<section role="content">`）中，同一父容器下的内容单元可以平级自由移动。


#### 结构类

内部不能直接包含文本或内联元素，如果没有标准的内部子结构，通常采用段落 `<p>` 元素来包含主体文本。

```html
<!--                                     说明：name -->
<header role="abstract"></header>   <!-- 提要：abstract /h3, p... -->
<nav role="toc"></nav>              <!-- 目录：toc /h4, ol/li/a（可多级） -->
<header></header>                   <!-- 导言：header /h4, p... -->
<footer></footer>                   <!-- 结语：footer /h4, p... -->
<section role="s1"></section>       <!-- 片区：h2, section.s1, -->
<section role="s2"></section>       <!-- 片区：h3, section.s2, -->
<section role="s3"></section>       <!-- 片区：h4, section.s3, -->
<section role="s4"></section>       <!-- 片区：h5, section.s4, -->
<section role="s5"></section>       <!-- 片区：h6, section.s5, -->
<ul></ul>                           <!-- 无序列表：ul /li/... -->
<ul role="seealso"></ul>            <!-- 另参见：seealso /li/... -->
<ol></ol>                           <!-- 有序列表：ol /li/... -->
<ol role="cascade"></ol>            <!-- 多级编号列表：cascade /li/h5, ol, ... -->
<ol role="codelist"></ol>           <!-- 代码表：codelist /li/code/b, #text -->
<ol role="references"></ol>         <!-- 文献参考：references /li/... -->
<dl></dl>                           <!-- 定义列表：dl /dt, dd/... -->
<table></table>                     <!-- 表格：table /caption, thead, tbody, tfoot/tr/td/... -->
<figure></figure>                   <!-- 插图：figure /figcaption, p... -->
<blockquote></blockquote>           <!-- 引用块：blockquote /h4, p... -->
<aside></aside>                     <!-- 批注：aside /h4, p... -->
<details></details>                 <!-- 详细内容：details /sumary, p... -->
<pre role="codeblock"></pre>        <!-- 代码块：codeblock /code/b, #text -->
```


#### 文本类

可直接包含文本内容，同时脱离固定的DOM结构且单独占据一整行的块级容器元素。线条作为内容特例也划归为文本类，因为它就是内容本身。

```html
<p></p>                     <!-- 段落：p 通用内容容器 -->
<address></address>         <!-- 地址信息：address -->
<pre></pre>                 <!-- 预排版：pre 非代码块 -->
<hr />                      <!-- 线条：hr 特例 -->
<div role="space"></div>    <!-- 空白块：space 可用于交互展示 -->
```

> **概念：**<br>
> **内容元素**：指可以直接包含文本或其它内联元素，或其本身就是内容实体（`<img>`）的元素。<br>
> **内容单元**：指作为内容实体的行块单元，部分内容单元是内容元素，但两者的概念不同。如 `<li>` 和 `<td>` 都是内容元素但不是内容单元。<br>


### 行内单元

只能被包含在内容元素里，即通常所说的内联（`inline`）元素。

它们不能作为独立的行块出现在内容容器（如 `<section role="content">`）中，即：它们不属于**内容单元**，它们必须被文本类行块单元封装才能成为内容单元。大部分内联元素属于内容元素。

```html
<!--                             说明：name -->
<audio></audio>             <!-- 音频：audio /track,source, #text -->
<video></video>             <!-- 视频：video /track,source, #text -->
<picture></picture>         <!-- 图片：picture /source,img -->
<a></a>                     <!-- 链接：a -->
<strong></strong>           <!-- 重点：strong -->
<em></em>                   <!-- 强调：em -->
<q></q>                     <!-- 短引用：q -->
<abbr></abbr>               <!-- 缩写：abbr -->
<cite></cite>               <!-- 来源：cite -->
<small></small>             <!-- 注脚：small -->
<time></time>               <!-- 时间：time -->
<del></del>                 <!-- 删除：del -->
<ins></ins>                 <!-- 插入：ins -->
<sub></sub>                 <!-- 下标：sub -->
<sup></sup>                 <!-- 上标：sup -->
<mark></mark>               <!-- 标记：mark -->
<code></code>               <!-- 代码：code -->
<code role="orz"></code>    <!-- 表情：orz -->
<ruby></ruby>               <!-- 注音：ruby /rb,rp,rt -->
<dfn></dfn>                 <!-- 定义：dfn -->
<samp></samp>               <!-- 样本：samp -->
<kbd></kbd>                 <!-- 键盘字：kbd -->
<s></s>                     <!-- 失效：s -->
<u></u>                     <!-- 注记：u -->
<var></var>                 <!-- 变量：var -->
<bdo></bdo>                 <!-- 文本方向：bdo -->
<meter></meter>             <!-- 度量：meter -->
<b>                         <!-- 粗体：b 主要用于代码块内的关键字包裹 -->
<i>                         <!-- 斜体：i 主要用于图标占位（icon） -->
<img />                     <!-- 图片：img -->
<span role="blank"></span>  <!-- 空白段：blank -->
#text                       <!-- 文本节点：#text -->
```



## 内容的类型

```js
{
// 结构单元
// BLOTHS：table|hr|space
// BLOUFCPC：ul|figure|codelist|pre|codeblock
abstract:   'ABSTRACT',
toc:        'TOC',
header:     'HEADER',
footer:     'FOOTER',
s1:         'S1',
s2:         'S2',
s3:         'S3',
s4:         'S4',
s5:         'S5',
ol:         'OL',
ul:         'BLOUFCPC', // 基本块（ul, figure, codelist, pre, codeblock）
seealso:    'SEEALSO',
cascade:    'CASCADE',
codelist:   'BLOUFCPC',
references: 'REFERENCES',
dl:         'DL',
table:      'BLOTHS',   // 基本块（table, hr, space）
figure:     'BLOUFCPC',
blockquote: 'BLOCKQUOTE',
aside:      'ASIDE',
details:    'DETAILS',
codeblock:  'BLOUFCPC',

// 文本单元
p:          'P',
address:    'ADDRESS',
pre:        'BLOUFCPC',
hr:         'BLOTHS',
space:      'BLOTHS',

// 限定中间单元
codeli:     'CODELI',       // codelist: li/code/
cascadeli:  'CASCADELI',    // cascade: li/h5, ol/

// 内联单元。
// 取值时会提取元素本身，因此配置为同一类。
audio:      'INLINE',
video:      'INLINE',
picture:    'INLINE',
strong:     'INLINE',
em:         'INLINE',
q:          'INLINE',
abbr:       'INLINE',
cite:       'INLINE',
small:      'INLINE',
time:       'INLINE',
del:        'INLINE',
ins:        'INLINE',
sub:        'INLINE',
sup:        'INLINE',
mark:       'INLINE',
orz:        'INLINE',
ruby:       'INLINE',
dfn:        'INLINE',
samp:       'INLINE',
kbd:        'INLINE',
s:          'INLINE',
u:          'INLINE',
bdo:        'INLINE',
meter:      'INLINE',
blank:      'INLINE',
var:        'INLINE',

// 会被作为特定的子单元使用。
a:          'A',
code:       'CODE',
img:        'IMG',
i:          'I',
b:          'B',
$text:      '$TEXT',


// 简单元素
h2:         'H2',
h3:         'H3',
h4:         'H4',
h5:         'H5',
h6:         'H6',
summary:    'SUMMARY',
figcaption: 'FIGCAPTION',
li:         'LI',
dt:         'DLI',
dd:         'DLI',

rb:         'RBPT',
rp:         'RBPT',
rt:         'RBPT',
track:      'TRACK',
source:     'SOURCE',

// 表格单独处理。
caption:    'CAPTION',
thead:      'TSEC',
tbody:      'TSEC',
tfoot:      'TSEC',
tr:         'TR',
th:         'TCELL',
td:         'TCELL',
}
```


### 合法子类型

每个结构性元素或内容单元的子单元类型都是有限定的。插入节点内容时会考虑：

1. 目标参考元素的父元素允许哪些子单元？符合即简单插入，否则检查是否需要/可以转换？
2. 目标参考元素自身作为容器允许哪些子单元，符合即简单添加，否则检查是否需要/可以转换？

> **注：**<br>
> 转换时通常是创建一个默认的空子单元，然后提取源数据填充。<br>
> 空的子类型表示不能直接插入内容，需使用其特有的接口操作。<br>


```js
{
abstract:   [ H3, P, BLOTHS ],
toc:        [ H4, CASCADE ],
header:     [ H4, P, BLOTHS ],
footer:     [ H4, P, BLOTHS, BLOCKQUOTE, SEEALSO, REFERENCES, ADDRESS ],
s1:         [ H2, HEADER, S2, FOOTER ],   // 注：对Content为转换检测。
s2:         [ H3, HEADER, S3, FOOTER ],   // 注： 同上
s3:         [ H4, HEADER, S4, FOOTER ],   // 注： 同上
s4:         [ H5, HEADER, S5, FOOTER ],   // 注： 同上
s5:         [ H6, HEADER, CONTENT, FOOTER ],
content:    [ P, BLOTHS, OL, BLOUFCPC, DL, BLOCKQUOTE, ASIDE, DETAILS, CASCADE, ADDRESS ],
ul:         [ LI ],
seealso:    [ LI ],
ol:         [ LI ],
cascade:    [ CASCADELI ],
codelist:   [ CODELI ],
references: [ LI ],
dl:         [ DLI ],
table:      [ CAPTION, TSEC ],
figure:     [ FIGCAPTION, P ],
blockquote: [ H4, P, BLOTHS, OL, BLOUFCPC, BLOCKQUOTE ],
aside:      [ H4, P, BLOTHS, OL, BLOUFCPC, BLOCKQUOTE, ADDRESS ],
details:    [ SUMMARY, P, BLOTHS, OL, BLOUFCPC, BLOCKQUOTE ],
codeblock:  [ CODE ],   // pre/code

// 文本类行块。
p:          [ $TEXT, INLINE, CODE, IMG ],
address:    [ $TEXT, INLINE, CODE, IMG ],
pre:        [ $TEXT, INLINE, CODE, IMG ],
hr:         [], // 空
space:      [], // 空，用于交互展示

// 限定中间结构
codeli:     [ CODE ],
cascadeli:  [ H5, OL ]

// 内联单元
audio:      [ TRACK, SOURCE ],  // 文本仅初始构造时包含，不支持后期注入
video:      [ TRACK, SOURCE ],  // 同上
picture:    [ SOURCE, IMG ],
a:          [ $TEXT, INLINE, IMG ],
strong:     [ $TEXT, INLINE ],
em:         [ $TEXT, INLINE ],
dfn:        [ $TEXT, INLINE ],
abbr:       [ $TEXT ],
time:       [ $TEXT ],
kbd:        [ $TEXT ],  // 键盘输入
code:       [ $TEXT, B ],
orz:        [ $TEXT ],
meter:      [ $TEXT ],  // 范围计量
ruby:       [ RBPT, $TEXT ],
q:          [ $TEXT, INLINE, A ],
small:      [ $TEXT, INLINE, A ],
samp:       [ $TEXT, INLINE, A ],   // 计算机输出
u:          [ $TEXT, INLINE, A ],   // 特别标注
bdo:        [ $TEXT, INLINE, A ],
cite:       [ $TEXT, INLINE, A ],
del:        [ $TEXT, INLINE, A ],
ins:        [ $TEXT, INLINE, A ],
s:          [ $TEXT, INLINE, A ],
sub:        [ $TEXT, INLINE, A ],
sup:        [ $TEXT, INLINE, A ],
mark:       [ $TEXT, INLINE, A ],
b:          [ $TEXT ],  // 简单支持
i:          [ $TEXT ],  // 同上
var:        [ $TEXT ],  // 变量标注

img:        [], // 空
blank:      [], // 空，用于交互展示

// 定制中间结构
// 注：I 可用于标题序号或背景按钮。
h2:         [ $TEXT, INLINE, I, A ],
h3:         [ $TEXT, INLINE, I, A ],
h4:         [ $TEXT, INLINE, I, A ],
h5:         [ $TEXT, INLINE, I, A ],
h6:         [ $TEXT, INLINE, I, A ],
figcaption: [ $TEXT, INLINE, I, A ],
summary:    [ $TEXT, INLINE, CODE, I, A ],
li:         [ $TEXT, INLINE, CODE, IMG, A ],
dt:         [ $TEXT, INLINE, CODE, I, A ],
dd:         [ $TEXT, INLINE, CODE, IMG, A ],

// 原生中间结构。
caption:    [ $TEXT, INLINE, I, A ],
thead:      [ TR ],
tbody:      [ TR ],
tfoot:      [ TR ],
tr:         [ TCELL ],
th:         [ $TEXT, INLINE, I, A ],
td:         [ $TEXT, INLINE, CODE, I, IMG, A ],

rb:         [ $TEXT ],
rp:         [ $TEXT ],
rt:         [ $TEXT ],
track:      [], // 空，单标签
source:     [], // 空，同上
}
```


## 单元结构

内容单元是独立完整的区块，普通区块如果有标题，采用 `<h4>` 级别。文章摘要属于顶层区块，标题采用 `<h3>` 级别。


### 原生结构

#### 导言

```html
<header>
    <h4></h4> <!-- 可选 -->
    <p></p> ...
</header>
```


#### 片区

片区包含4个逻辑部分：**导言**、**标题**、**内容区**、**结语**。4个部分是并列的关系，并不被包含在一个统一的容器里。

```html
<header></header>   <!-- 导言：可选 -->
<h2> ~ <h6>         <!-- 标题 -->
<section>           <!-- 内容区 -->
    [ Text ]...
</section>
<footer></footer>   <!-- 结语：可选 -->
```


#### 结语

```html
<footer>
    <h4></h4> <!-- 可选 -->
    <p></p> ...
</footer>
```


#### 无序列表

```html
<ul>
    <li></li>
</ul>
```


#### 有序列表

```html
<ol>
    <li></li>
</ol>
```


#### 定义列表

```html
<dl>
    <dt></dt>
    <dd></dd>
</dl>
```


#### 表格

```html
<table>
    <caption></caption>
    <thead> <!-- 可选 -->
        <tr><td></td></tr>
    </thead>
    <tbody>
        <tr><td></td></tr>
    </tbody>
    <tfoot> <!-- 可选-->
        <tr><td></td></tr>
    </tfoot>
</table>
```


#### 插图

```html
<figure>
    <figcaption></figcaption>
    <p>
        <img />...
    <p>
</figure>
```


#### 详细内容

从内容逻辑和浏览器的视觉实现上看，本区块的摘要（标题）与内容有明显的区隔，因此内容部分采用单独的容器封装（而不是平级罗列）。

```html
<details>
    <summary></summary>
    <section>
        [内容单元]...
    </section>
</details>
```


#### 引用块

```html
<blockquote>
    <h4></h4>   <!-- 可选 -->
    <p><p> ...  <!-- 平级罗列 -->
</blockquote>
```


#### 批注

```html
<aside>
    <h4></h4> <!-- 可选 -->
    <p><p> ...
</aside>
```



#### 代码块

```html
<pre role="codeblock"><!-- 容许简单换行 -->
<code data-lang="xx"> ...<b></b>...
</code><pre> <!-- 末尾应当紧跟 -->
```


#### 注音

```html
<ruby>
    <rb>漢</rb><rp>（</rp><rt> ㄏㄢˋ </rt><rp>）</rp>
</ruby>
```


### 定制结构

#### 提要

```html
<header role="abstract">
    <h3>摘 要</h3>
    <p></p> ...
</header>
```

#### 目录

```html
<nav role="toc">
    <h4></h4>
    <ol role="cascade">
        <li><h5><a href="#..."></a></h5></li>
    </ol>
</nav>
```

#### 级联编号表

级联编号表仅由有序列（`<ol>`）表构成，除了最后（深）的层级，列表项（`<li>`）中仅有两个元素成员：可选的小标题（`<h5>`）、子列表（`<ol>`）。

> **注：**<br>
> 有序（`<ol>`）和无序（`<ul>`）列表的混合嵌套也是一种级联表，但它们属于正常的DOM结构，不在这里特别区分。

```html
<ol role="cascade">
    <li></li> <!-- 由CSS表达序号规则 -->
    <li><h5></h5> ...
        <ol>
            <li></li>
        </ol>
    </li>
</ol>
```

#### 代码表

```html
<ol role="codelist">
    <li><code data-lang="xx"> <!-- 根封装 -->
        ...<b></b>... <!-- 代码内容，<b>着色封装 -->
    </code></li>
    <li><code data-lang="xx"> ... </code></li>
</ol>
```

**注**：所有代码的data-lang属性仅设置在 `<code>` 元素上。


## 代码着色

### 封装规则

考虑简单性，代码内的高亮着色采用 `<b>` 元素封装，通过 `class` 类名区分。所有 `<b>` 元素只会处于同一层级（`<code>` 直接子元素），没有嵌套。

基本类名定义如下：

```css
b.cmt   /* comments */
b.str   /* string */
b.kws   /* keywords */
b.tag   /* tag-name */
b.slr   /* selector */
b.atn   /* attribute-name */
b.atv   /* attribute-value */
b.fun   /* function-work */
b.typ   /* data-type */
b.imp   /* important */
b.doc   /* <!DOCTYPE...> */
b.cdt   /* <![CDATA[...]]> */
b.rex   /* js-RegExp */
b.non   /* invalid */
```

### 示例

#### 源码1（代码块）

```html
<pre>
<code data-lang="go"><b class="cmt">// prints its command-line arguments.</b>
<b class="kws">package</b> main

<b class="kws">import</b> (
    <b class="str">"fmt"</b>
    <b class="str">"os"</b>
)

<b class="kws">func</b> main() {
    <b class="kws">var</b> s, sep <b class="typ">string</b>
    <b class="kws">for</b> i := 1; i &lt; <b class="fun">len</b>(os.Args); i++ {
        s += sep + os.Args[i]
        sep = <b class="str">" "</b>
    }
    fmt.Println(s)
}</code></pre>
```

#### 效果

```go
// Echo1 prints its command-line arguments.
package main

import (
    "fmt"
    "os"
)

func main() {
    var s, sep string
    for i := 1; i < len(os.Args); i++ {
        s += sep + os.Args[i]
        sep = " "
    }
    fmt.Println(s)
}
```

#### 源码2（代码表）

```html
<ol role="codelist" class="codelist">
    <li><code data-lang="go"><b class="kws">package</b> main</code></li>
    <li><code data-lang="go"><b class="kws">import</b> <b class="str">"fmt"</b></code></li>
    <li><code data-lang="go"><b class="kws">func</b> main() {</code></li>
    <li><code data-lang="go">    fmt.Println(<b class="str">"Hello, 世界"</b>) <b class="cmt">// 通过导入的 fmt 包，执行 Println 函数向控制台打印消息。</b></code></li>
    <li><code data-lang="go">}</code></li>
    <li><code data-lang="go"><b class="kws">type</b> MapSort <b class="kws">struct</b> {</code></li>
    <li><code data-lang="go">    m <b class="kws">map</b>[<b class="typ">string</b>]<b class="typ">int</b></code></li>
    <li><code data-lang="go">    s []<b class="typ">string</b></code></li>
    <li><code data-lang="go">}</code></li>
</ol>
```

#### 效果

```go
package main
import "fmt"
func main() {
    fmt.Println("Hello, 世界") // 通过导入的 fmt 包，执行 Println 函数向控制台打印消息。这是一个长行。
}
type MapSort struct {
    m map[string]int
    s []string
}
```

**注**：html页面中实际会显示行号。
