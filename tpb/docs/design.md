# Tpb 详细设计

> `tpb`: Template Presentational Behavior


## 目的

在HTML上简单直观地设计UI。因为UI的交互逻辑也应当属于页面设计师的工作，所以事件的绑定规划也需要包含。

HTML的代码有着严格的树形结构，虽然浏览器可以正常解析杂乱无章的HTML源码，但这样的结构也可以是人工友好的，设计师可以在这样的树形结构中思考。同时，简明清晰的HTML源码既方便分享，也可以节省数据的存储和流量。

HTML源码不应当脱离设计师的视野，**源码**这一逻辑也并不就是程序员专属，实际上，HTML就是一种模板，在模板上定义交互逻辑十分正常。因此，本设计中的事件绑定在模板中定义，由设计师完全主导。设计师唯一需要知道的是有哪些数据可用，而这些数据都是纯数据，与页面展示无关。

同时，程序员也不需要知道数据将如何展现，即：理论上，数据中不应当有HTML标签结构。



## 指令

以模板为驱动，功能指令书写在HTML元素上，自动解析完成事件的绑定和行为序列的编译。

1. **行为定义：**<br>
    由三个属性 `on`、`by`、`to` 定义，在元素上配置需要处理的事件和相应的行为链。其中：
    - `on`：事件绑定和取值逻辑。
    - `by`：具体的业务处理。可以在内部划分为 `EMR`（`Entry`, `Model`, `Render`）三个环节，可选。
    - `to`：用业务环节来的数据更新UI。逻辑上可选，但通常是必需的。

2. **节点渲染：**<br>
    由十个渲染属性 `tpb-[for|each|if|elseif|else|with|var|switch|case|default]` 表达模板的语法结构，以及一个 **属性名前置下划线** 指定属性赋值的规则，如：`_href="$.url"` 表示对 `href` 属性赋值为变量 `url` 的值，单独的属性名 `_` 指对元素内容赋值。
    - `tpb-for`: 子元素的循环。
    - `tpb-each`: 当前元素的循环迭代。
    - `tpb-if`: 当前元素 if 测试，真值显示，假值移除。下同。
    - `tpb-elseif`: 当前元素 `elseif` 测试，与 `if` 匹配使用。
    - `tpb-else`: 当前元素 `else` 测试，与 `if` 匹配使用。
    - `tpb-with`: 新建局部域，变量引用为局部域成员。
    - `tpb-var`: 新建变量，方便后续简化使用。
    - `tpb-switch`: 创建子元素 `switch` 逻辑。
    - `tpb-case`: 当前元素 `case` 测试，与 `switch` 标的值比较，相等则显示，否则移除。
    - `tpb-default`: 当前元素的 `switch` 默认分支，其它 `case` 不匹配时显示，否则移除。

3. **模板管理：**<br>
    由两个属性 `tpl-[name|load]` 配置。
    - `tpl-name`: 当前元素命名为一个具名模板，用于外部检索或子模版导入时引用。
    - `tpl-load`: 标记当前元素为一个容器，内部需要导入目标名称的子模版。



## OBT基本规则

`OBT` 即为**行为定义**中 `on/by/to` 的简写。事件/行为在这三个属性上定义，系统自动解析，绑定目标事件名并构造相应的行为链，完成页面的UI逻辑。

行为链可视为一个指令（方法）序列，它们对一个数据栈进行操作。通常，栈内数据需要取出后再处理，它们是方法操作的目标。取出的数据称为**当前条目**，存放该条目的地方称为**暂存区**。暂存区是一次性使用，用过即空的逻辑。如果暂存区没有操作目标，系统会自动从栈顶取值（取出而非复制）。

形象地看，行为链有点类似于流水线（也称为执行流），数据栈里的数据就是流程数据，链上的指令操作这些数据，而返回值也都自动入栈（除了 `undefined`）。

> **注：**<br>
> 每一个指令调用后都应当让暂存区被重置，即便当前条目未使用。因此方法的取栈条目数应当至少设置为 `0`，除非这些方法本身就是在设置暂存区。


### 分组对应的配置格式

`On/By/To` 上的配置可以有多组，每一组用分号（`;`）分隔，多组之间严格地按位置对应，如：

```html
<article
    on="AA; BB; CC"
    by="Xx; -;  Zz"
    to="T1; T2">
</article>
<!-- 注：分号后的空格可选 -->
```

**说明：**

- **`{ AA / Xx / T1 }`** 为一组行为链，分别对应于 `On / By / To` 各自的逻辑。
- **`{ BB / - / T2 }`**  为一组行为链，OBT对应逻辑同上，但其中 `By` 是一个空值（无定义，`-` 为占位符）。
- **`{ CC / Zz / - }`**  为一组行为链，OBT对应逻辑同前，但末尾的 `To` 没有定义（占位符在末尾时可省略）。


### 隐形的首个实参

所有方法中的首个实参都为 `evo`（event-value-object），它们是在方法调用时自动传入的，在模板中并不可见。

```js
evo: {
    origin: {Element}               // 事件起点元素（event.target）
    current: {Element}              // 触发事件的当前元素（event.currentTarget|matched）
    related: {Element|null}         // 事件相关联元素（event.relatedTarget）
    delegate: {Element|undefined}   // 委托绑定的元素（event.currentTarget）

    selector: {String|undefined}    // 委托匹配选择器（for match）]
    event: {Event}                  // 原生事件对象（未侵入）
    data: {Value|[Value]}           // 自动获取的流程数据
    targets: {Element|Collector}    // To目标元素（集）向后延续
}
```

其中 `evo.data` 是由数据栈中取出的条目，通常是方法操作的目标。是否从数据栈中取值或取值的特性由方法的 `targetCount` 属性配置，含义如下：

- `0`  暂存区有值则返回，不自动取栈
- `1`  暂存区有值则返回，否则取栈顶1项（值）
- `n`  暂存区有值则返回，否则取栈顶n项（Array）
- `null|undefined` 无需流程数据。`evo.data` 为 `undefined`。


#### 附：流程数据依赖的三种情形

1. 如果方法**明确需要**有操作目标，此时应当要求自动取栈。`targetCount` 配置为需要的流程数据条目数。
2. 如果目标**可有可无**，此时目标应该是可选的，不应当要求自动取栈。`targetCount` 配置值为 `0`。
3. 如果方法没有对流程数据的要求，即无需操作目标。此时 `targetCount` 配置值应该为 `null`。



## 全局指令集

### 顶层全局（适用 On/By/To 三个域）

```js
$( rid: String | null ): Element
// 检索元素入栈：tQuery.get( down, up )
// 目标：当前条目。不自动取栈。
// rid:
// - String 以当前条目或事件当前元素为起点，上/下检索目标元素。
// - null   以当前条目为rid。
// 注：
// 当前条目充当2种角色，起点元素或rid替代。

$$( rid: String | Value | null ): Collector
// 检索元素集入栈：tQuery(...)
// 目标：当前条目。不自动取栈。
// rid:
// - String （同上）
// - null   已当前条目为rid。
// - Value  非预设类型/值时，封装为Collector。
// 注：
// 当前条目充当2种角色：起点元素和rid替代（实参为null时）。
// 如果rid实参为null而当前条目非字符串时，当前条目值封装为Collector。

evo( name: String | Number ): Value
// 从当前evo对象上取值入栈。
// name: {
//      0|'origin'    evo.origin
//      1|'current'   evo.current
//      2|'delegate'  evo.delegate
//      3|'related'   evo.related
//      8|'selector'  evo.selector
//      9|'event'     evo.event
//     10|'data'      evo.data （前端最后取出值遗留）
//     11|'targets'   evo.targets （To检索目标延续传递）
// }
// 目标：从（隐藏的）首个实参上取值。无需当前条目。
// 实现：name:[n => s]; evo[ name[x] || x ]

ev( ...name: String | [String] ): Value | [Value]
// 从事件对象上取值入栈。
// name为事件对象内的成员名，多个实参取值会自动展开入栈。
// name: {
//      'key':      evo.event.key
//      'detail':   evo.event.detail
//      '...':      evo.event[...]
// }
// 目标：实参事件对象。无需当前条目。
// 特权：是。自主入栈。
// 注：
// 如果需要入栈一个值集，实参自身需要是一个数组。

nil(): void
// 一个空行为，占位。
// 既不从暂存区取值，也不向数据栈添加值。
// 目标：无。
// 通常在On无需取值时作为视觉友好使用。如：click|nil;

del( start, count ): void
// 删除栈任意位置段条目，位置指定支持负数从末尾算起。
// 目标：无。
// 特权：是。栈操作。
// 注：
// 纯粹删除功能，被删除的值不进入暂存区。

hello( ...msg: Value ): void
// 向控制台打印消息。
// 目标：当前条目，不自动取栈。
// 实参序列优先于当前条目。
// 测试用途。


// 控制类
//===============================================

pass( val? ): void
// 通过检测。
// 测试通过则继续，否则中断执行流。
// 目标：当前条目/栈顶1项。
// val:
// 有值则为相等（===）测试，否则为真值测试。

avoid( back? ): back|void
// 停止事件默认的行为。
// 即调用 event.preventDefault()
// 目标：当前条目，不自动取栈。
// 如果当前条目非空，则真值执行。否则无条件执行。
// back：
// 执行之后的返回值（入栈，用户定义），如果未执行则无效。

stop( back? ): back|void
// 停止事件冒泡。
// 即调用 event.stopPropagation()。
// 目标：当前条目，不自动取栈。
// 如果当前条目非空，则真值执行。否则无条件执行。
// back：同上。

stopAll( back? ): back|void
// 停止事件冒泡并阻止本事件其它处理器的执行。
// 即调用 event.stopImmediatePropagation()
// 目标：当前条目，不自动取栈。
// 如果当前条目非空，则真值执行。否则无条件执行。
// back：同上。

end(): void
// 流程终止。
// 目标：当前条目，不自动取栈。
// 如果当前条目非空，则真值终止，否则无条件终止。


// 暂存区赋值
// 赋值为单值或数组。
// 目标：无。
//===============================================

pop( n ): void
// 弹出栈顶 n 个条目。
// 明确指定n值构建为一个数组。
// 无实参调用弹出末尾条目，作为单个值赋值。
// 即：pop() 和 pop(1) 的返回值不一样。
// pop(0) 不会弹出任何内容，但会创建一个空集赋值。
//
// 弹出：单值|数组。

slice( begin, end ): void
// 复制数据栈某区段条目，构造为一个数组。
// 两个下标位置支持负数。
//
// 克隆：任意区段，数组。

index( n ): void
// 引用数据栈n位置的单个值赋值到暂存区。
//
// 引用：任意位置，单值。

indexes( ...n ): void
// 引用数据栈多个位置的值赋值到暂存区。
//
// 引用：任意位置，集合。


// 下面的方法会移除栈内条目
//-----------------------------------------------
// 逻辑上这不是栈操作，但JavaScript中的数组提供了这种能力。
// 因此这里提供相关方法，应该不常用。

shift( n ): void
// 移除栈底 n 个条目，可能构建为一个数组。
// 无实参调用移除首个条目，作为单个值赋值。
// 即：shift() 和 shift(1) 返回值不同。
//
// 移除：单值|数组。

splice( start, count ): void
// 移除数据栈某区段条目，构造为一个数组。
// start下标位置支持负数。
//
// 移除：任意区段，数组。

pick( idx ): void
// 移除数据栈idx位置的单个值赋值到暂存区。
// 赋值为单个值，效果同：splice(idx, 1)[0]
//
// 移除：任意位置，单值。
```


### 运算全局（仅用于 On/By 两个域）

```js
// 类型转换
// 目标：当前条目/栈顶1项。
//===============================================

Arr( ext: Boolean ): Array
// 转换为数组。
// 如果ext为真，表示扩展目标为一个新数组（Array.from）。
// 否则只是简单的封装目标为一个单值数组（Array.of）。

Str( prefix?, suffix? ): String
// 转换为字符串。
// 可以选择性的添加前/后缀。

Bool(): Boolean
// 转换为布尔值（false|true）
// '', 0, false, null, undefined 为假，其它为真。

Int( radix ): Number
// 将字符串转为整数，即 parseInt()

Float(): Number
// 将字符串转为浮点数，即 parseFloat()


// 简单值操作。
//===============================================

env( name: String, its?: Value | String ): void | Value
// 全局环境设置或取值。
// 目标：当前条目。不自动取栈。
// 目标非空或its有值时为设置，目标为空且its未定义时为取值入栈。
// 设置时：
// - 目标为空：its必然有值，否则为取值逻辑。
// - 目标非空：its有值，its指属性名，取该属性值设置。‘
//
// 注：操作Globals对象。

data( name, its?: Value | String ): void | Value
// 关联数据存储/取出。
// 目标：当前条目。不自动取栈。
// 存储元素（evo.delegate）关联的数据项或取出数据项入栈。
// 通常实现为一个WeakMap存储当前元素的关联数据。
// 数据本身是一个Map对象：
// - 数据项键：name。
// - 数据项值：目标对象、its、或目标对象的[its]属性值。
// 注：
// 设置时的目标对象和its的逻辑同env指令。
// 操作WeakStore存储空间。

push( ...val: Value | [Value] ): Value | [Value]
// 直接赋值入栈。
// 目标：可选当前条目。不取栈（0）。
// 特权：是。自行入栈操作。
// 多个实参会自动展开入栈，数组实参视为单个值。
// 无实参调用时入栈当前条目（作为单一值）。
// 如果暂存区有值同时也传入了实参，则实参有效，当前条目作废。
// 注记：
// 入栈当前条目的能力使得可以组合多个栈数据为单一条目。
// 这在打包多个实参作单一递送时有用。

get( ...name: String | [String] ): Value | [Value]
// 取目标成员值入栈。
// 目标：当前条目/栈顶1项。
// 特权：是。自行入栈操作。
// 注：
// 多个名称取值会自动展开入栈。
// 如果需要入栈值集合，需要明确传递名称数组。

call( meth, ...rest ): Value
// 调用目标的方法执行。
// 目标：当前条目/栈顶1项。


$if( val, else ): Value
// 条件赋值。
// 如果目标值为真，返回val入栈，否则跳过。
// 目标：当前条目/栈顶1项。
// 特权：是。可能两次赋值（入栈）。
// else：是否构造else逻辑。
// - 目标为真，赋值。补充追加一个false（待后续$if取值）。
// - 目标为假，不赋值val。赋值一个true（后续$if必然执行）。
// 例1：
// $if('alert(msg);')
// 如果目标为真，入栈弹出消息代码。简单if。
// 注：后续需配合func/exec指令执行代码：func('msg') exec('hai')
// 例2：
// $if('AAA', true) $if('BBB')
// 如果目标为真赋值AAA，补充赋值一个false，第二个$if必然跳过。


// 集合操作
//===============================================

filter( fltr: String, js: Boolean ): [Value]
// 值集过滤。
// 匹配者构建一个新数组入栈。适用元素和普通值集。
// 目标：当前条目/栈顶1项。
// js 说明fltr是否是一个JS表达式。
// fltr 若为表达式，固定参数名：(v, i, o)。
// 注：
// 表达式无需包含 return。
// 目标需要是一个集合。

not( fltr: String, js: Boolean ): [Value]
// 值集排除。符合者被排除，剩余的创建为一个新集合入栈。
// 适用元素和普通值集。
// 目标：当前条目/栈顶1项。
// 参数说明同上。

has( slr: String ): [Element]
// 子成员包含。
// 目标：当前条目/栈顶1项。
// 仅适用于元素集，普通值集无效。

flat( deep: Number, ext: Boolean = false )
// 集合扁平化。
// 将目标内可能嵌套的数组扁平化处理。
// 目标：当前条目/栈顶1项。
// 特权：是。自行展开入栈。
// ext指示是否展开入栈。
// deep可为0，这时通常ext为true，表示单纯的集合展开。



// 简单运算
//===============================================

add(): Number   // (x, y) => x + y
sub(): Number   // (x, y) => x - y
mul(): Number   // (x, y) => x * y
div(): Number   // (x, y) => x / y
mod(): Number   // (x, y) => x % y
// 标准算术。
// 目标：当前条目/栈顶2项。

divmod(): [Number, Number]
// 除并求余。(x, y) => [x/y, x%y]
// 目标：当前条目/栈顶2项。

nneg(): Number | [Number]
// 数值取负（-x）。
// 目标：当前条目/栈顶1项。
// 注：
// 兼容集合处理（每一个成员取负）。

vnot(): Boolean | [Boolean]
// 逻辑取反（!x）。
// 目标：当前条目/栈顶1项。
// 注：兼容集合处理。


dup( n = 1 ): Value | [Value]
// 栈顶复制（浅）。
// 目标：当前条目，不取栈。
// 特权：是。多条目克隆压入。
// 传递n为null，取当前条目为复制数量。
// 无参数调用时，n默认取1。
// 附：
// 效果与 `slice(-n), flat(0, true)` 相同。

clone( event, deep, eventdeep ): Element | Collector
// 专用：元素克隆。
// 目标：当前条目/栈顶1项。
// 注：兼容集合处理。

calc( expr ): Value
// 目标计算。
// 目标：当前条目/栈顶1项。
// 用$引用目标数据，计算表达式（无需return）。
// 例：
// calc('($[0] + $[1]) * $[2]')

assign( target ): Object
// 对象赋值。
// 目标：当前条目/栈顶1项。
// 目标为数据源，数组条目自动展开为多个实参。
// 注：因此无法支持数组本身为数据源。


// 比较运算
// 目标：当前条目/栈顶2项。
//===============================================

equal(): Boolean    // (x, y) => x === y
nequal(): Boolean   // (x, y) => x !== y
lt(): Boolean       // (x, y) => x < y
lte(): Boolean      // (x, y) => x <= y
gt(): Boolean       // (x, y) => x > y
gte(): Boolean      // (x, y) => x >= y


// 逻辑运算
//===============================================
// 下面的 $expr 为测试表达式或函数名，表达式可用参数名：（v, i, o）。
// $expr 支持首字符问号（?）引用X函数库成员。


within( min, max ): Boolean
// 是否在 [min, max] 的范围内（包含边界值）。
// 目标：当前条目/栈顶1项。

include( ...vals ): Boolean
// 是否在实参序列内。
// 目标：当前条目/栈顶1项。
// 实现：Array.includes。

both(): Boolean
// 二者为真判断。
// 目标：当前条目/栈顶2项。

either(): Boolean
// 二者任一为真测试。
// 目标：当前条目/栈顶2项。

every( $expr ): Boolean
// 集合成员全为真测试。
// $expr 可选，默认简单真值判断。
// 目标：当前条目/栈顶1项。
// 注：目标必须是一个集合。

some( $expr ): Boolean
// 集合成员至少1项为真测试。
// $expr 可选，默认简单真值判断。
// 目标：当前条目/栈顶1项。
// 注：目标必须是一个集合。


// 其它
//===============================================

tpl( name: String | null ): Element | false
// 从模板管理器获取name模板。
// 目标：当前条目，不自动取栈。
// 实参名优先于当前条目传递的名称，如果想采用当前条目，实参可为任意假值。
// 注：
// 模板请求通常是异步的。
```



## 应用

### 交互文档

最简单的形式，让普通网页包含互动，不涉及向服务器请求新的数据。可为本地文件（`file://`）方式查看，适合普通的离线文档文章手册等。


### 动态页（Taker）

需要连网，页面可以向服务器实时请求数据更新页面。内容展示逻辑较简单，不包含向外请求新的模板。


### 页程序（WebApp）

功能复杂的页面应用，通常需要向服务器请求数据和新的模板，内部可进一步分解成 `EMR`（`Entry/Model/Render`） 三层逻辑。



## 附录

### 缩写

> `OBT`: `On-By-To` 在HTML页面中定义行为。
> `GPS`: `Get, Process, Set` 页面UI的整体逻辑。
> `EMR`: `Entry, Model, Render` 属于GPS中的Process深入分层（如果需要）。


### 事件

- `tplend`: 模板读取完毕。在 `document` 上触发。
- `tpldone`: 模板构建完毕，包括 `OBT` 解析绑定。在有 `OBT` 配置上的每一个元素上触发，不冒泡。


### 全局对象

- `OBT.on`： On 的方法集。
- `OBT.by`： By 的方法集。
- `OBT.to`： To 的方法集。


### 模板特殊字符

在模板中部分标点符号用于特别的目的。

- **`;`** 分号。分隔符，用于通用的逻辑区隔，如OBT定义分组。
- **`,`** 逗号。表示并列的关系，如参数列表、指令调用。
- **`|`** 竖线。递进处置，如输出数据的过滤处理、事件关联的行为链。
- **`-`** 横线。空值占位，主要用于OBT分组定义中的顺序保持。
- **`$`** 对当前域或父域对象的引用。


### X函数库引用

在某些方法中，字符串实参可以前置一个问号（`?`）来引用X函数库里的成员，用于向流程传入一个函数。
