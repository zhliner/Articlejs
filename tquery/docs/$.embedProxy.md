# $.embedProxy( getter ): tQuery | Proxy

对 `$` 嵌入 `get` 代理。由外部定义 `$` 的调用集覆盖，`getter` 接受函数名参数，应当返回一个与目标接口声明相同的函数。


## 参数

### getter: {Function}

`$` 内成员函数的获取函数。定义：`getter( name ): Function`，返回的函数的接口声明应当与 `[name]` 的定义相同。


## 返回值

返回原始 `tQuery`（首次调用时）或前阶被嵌入的代理对象（`Proxy`）。


## 示例

```html
<p id="test" class="Test Hai">
    这是一个<strong>测试</strong><em>段落</em>。
</p>
```


### 嵌入代理前

```js
p = $.get('#test');
$.hasClass(p, 'Test');      // true
$.hasClass(p, 'Hai');       // true
$.hasClass(p, 'Test Hai');  // true
$.hasClass(p, 'Hai Test');  // true
$.hasClass(p, 'Good');      // false
```


### 嵌入代理后

```js
let hasClassX = function( el, name ) {
    // 简单返回标签名和测试类名
    return `${el.tagName}: ${name}`;
};

let getter = function( fn ) {
    // 仅改变 hasClass 接口
    return (fn === 'hasClass') ? hasClassX : null;
};

$.embedProxy(getter);

$.hasClass(p, 'Test');  // "P: Test"
$.hasClass(p, 'Hai');   // "P: Hai"
$.hasClass(p, 'Good');  // "P: Good"

// 其它接口不受影响
$.attr(p, 'class');     // "Test Hai"
```


### 可多重嵌入代理

```js
// 嵌入之前
$.children(p);  // [<strong>, <em>]


function childrenX( el, slr ) {
    return `embed: ${el.nodeName}`;
}
let getter2 = fn => (fn === 'children') ? childrenX : null;

let $1 = $.embedProxy(getter2);


// 嵌入之后
$.children(p);          // "embed: P"

// 前阶代理依然有效
$.hasClass(p, 'Test');  // "P: Test"

// 无关接口保持原样
$.attr(p, 'id');        // "test"


// 使用前阶嵌入
// 注：前阶嵌入未修改children接口
$1.children(p);     // [<strong>, <em>]
```
