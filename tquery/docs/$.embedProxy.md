# $.embedProxy( getter ): tQuery | Proxy

对 `window.$` 嵌入 `get` 代理。由外部定义 `$` 成员的调用集覆盖，从而替换 `$` 成员方法的默认行为。


## 参数

### getter: Function

`$` 内成员方法的获取函数，接口：`function( name ): Function`，实参 `name` 即为当前调用的目标方法。

返回的方法应当与目标方法 `[name]` 有相同的声明和兼容的功能实现。


### 返回值

返回原始 `tQuery`（首次调用时），或前阶被嵌入的代理对象（`Proxy`）。


## 示例

```html
<p id="test" class="Test Hai">
    这是一个<strong>测试</strong><em>段落</em>。
</p>
```


### 嵌入代理前

```js
p = $.get('#test');
$.hasClass(p, 'Test');      // true
$.hasClass(p, 'Hai Test');  // true
$.hasClass(p, 'Good');      // false
```


### 嵌入代理后

```js
let hasClassX = function( el, name ) {
    // 简单返回标签名和测试类名
    return `${el.tagName}: ${name}`;
};

let getter = function( fn ) {
    // 仅改变 hasClass 接口
    return fn == 'hasClass' ? hasClassX : null;
};

$.embedProxy(getter);

$.hasClass(p, 'Test');  // "P: Test"
$.hasClass(p, 'Hai');   // "P: Hai"
$.hasClass(p, 'Good');  // "P: Good"

// 其它接口不受影响
$.attr(p, 'class');     // "Test Hai"
```


### 可多重嵌入代理

```js
// 嵌入之前
$.children(p);  // [<strong>, <em>]


function childrenX( el, slr ) {
    return `embed: ${el.nodeName}`;
}
let getter2 = fn => (fn === 'children') ? childrenX : null;

let $1 = $.embedProxy(getter2);


// 嵌入之后
$.children(p);          // "embed: P"

// 前阶代理依然有效
$.hasClass(p, 'Test');  // "P: Test"

// 无关接口保持原样
$.attr(p, 'id');        // "test"


// 使用前阶嵌入
// 注：前阶嵌入未修改children接口
$1.children(p);     // [<strong>, <em>]
```
